import { TableExampleSimple } from './examples/TableExampleSimple/TableExampleSimple';
import { TableExampleWidth } from './examples/TableExampleWidth/TableExampleWidth';
import { TableExampleSeparator } from './examples/TableExampleSeparator/TableExampleSeparator';
import { TableExamplePinned } from './examples/TableExamplePinned/TableExamplePinned';
import { TableExampleGroupColumns } from './examples/TableExampleGroupColumns/TableExampleGroupColumns';
import { TableExampleRenderCell } from './examples/TableExampleRenderCell/TableExampleRenderCell';
import { TableExampleRenderHeaderCell } from './examples/TableExampleRenderHeaderCell/TableExampleRenderHeaderCell';
import { TableExampleStickyHeader } from './examples/TableExampleStickyHeader/TableExampleStickyHeader';
import { TableExampleVirtualScroll } from './examples/TableExampleVirtualScroll/TableExampleVirtualScroll';
import { TableExampleZebraStriped } from './examples/TableExampleZebraStriped/TableExampleZebraStriped';
import { TableExampleNestedRows } from './examples/TableExampleNestedRows/TableExampleNestedRows';
import { TableExampleColSpan } from './examples/TableExampleColSpan/TableExampleColSpan';
import { TableExampleRenderRow } from './examples/TableExampleRenderRow/TableExampleRenderRow';
import { TableExampleWithIndicator } from './examples/TableExampleWithIndicator/TableExampleWithIndicator';
import { TableExampleAdaptiveColumns } from './examples/TableExampleAdaptiveColumns/TableExampleAdaptiveColumns';
import { TableExampleActiveRow } from './examples/TableExampleActiveRow/TableExampleActiveRow';
import { TableExampleActiveRowWithNumbering } from './examples/TableExampleActiveRowWithNumbering/TableExampleActiveRowWithNumbering';
import { TableExampleRowHoverEffect } from './examples/TableExampleRowHoverEffect/TableExampleRowHoverEffect';
import { TableExampleHoveredControlled } from './examples/TableExampleHoveredControlled/TableExampleHoveredControlled';
import {
  TableExampleResizableInside,
  TableExampleResizableOutside,
} from './examples/TableExampleResizable/TableExampleResizable';

import { MdxTabs, MdxMenu, MdxInformer } from '@consta/stand';

<MdxMenu>

- [Свойства](#свойства)
- [Как формируется таблица](#как-формируется-таблица)
- [Колонка](#колонка)
  - [Ширина колонки](#ширина-колонки)
  - [Разделитель колонок](#разделитель-колонок)
  - [Закрепление колонок](#закрепление-колонок)
  - [Группировка колонок](#группировка-колонок)
  - [Представление данных в ячейке](#представление-данных-в-ячейке)
  - [Представление данных в ячейке в шапке](#представление-данных-в-ячейке-в-шапке)
  - [Объединение ячеек](#объединение-ячеек)
- [Закрепление шапки](#закрепление-шапки)
- [Виртуальный скролл](#виртуальный-скролл)
- [Таблица в полоску](#таблица-в-полоску)
- [Выделение строк](#выделение-строк)
  - [Наведение на строку](#наведение-на-строку)
  - [Выбор строки](#выбор-строки)
- [Управление шириной столбцов](#управление-шириной-столбцов)
- [headerZIndex](#headerzindex)
- [Вложенные строки](#вложенные-строки)
- [Рендер строки](#рендер-строки)
- [Индикатор ячейки и подсказки](#индикатор-ячейки-и-подсказки)
- [Ключ строки](#ключ-строки)
- [Адаптивная ширина колонок](#адаптивная-ширина-колонок)

</MdxMenu>

## Как формируется таблица

Для вывода самой простой таблицы, используйте 2 свойства:

- `rows` - строки. Тип строки может быть любым массивом объекта `Record<string, unknown>`.
- `columns`- колонки. Представляют массив объектов, у которого `accessor` это свойство объекта ваших данных.

<MdxTabs>

<TableExampleSimple />

```tsx
import { Table, TableColumn } from '@consta/table/Table';

type Row = { name: string; profession: string; status: string };

const rows: Row[] = [
  {
    name: 'Антон',
    profession: 'Строитель, который построил дом',
    status: 'недоступен',
  },
  {
    name: 'Василий',
    profession: 'Отвечает на вопросы, хотя его не спросили',
    status: 'на связи',
  },
];

const columns: TableColumn<Row>[] = [
  {
    title: 'Имя',
    accessor: 'name',
  },
  {
    title: 'Профессия',
    accessor: 'profession',
  },
  {
    title: 'Статус',
    accessor: 'status',
  },
];

export const TableExampleSimple = () => <Table rows={rows} columns={columns} />;
```

</MdxTabs>

## Свойства

```ts
export type TableRenderHeaderCell = (props: {
  title?: string;
  index: number;
}) => React.ReactElement | null;

export type TableRenderCell<T> = (props: {
  row: T;
  rowIndex: number;
  columnIndex: number;
}) => React.ReactElement | null;

export type TableColumn<ROW> = {
  title?: string;
  width?:
    | number
    | 'auto'
    | '1fr'
    | '2fr'
    | '3fr'
    | '4fr'
    | '5fr'
    | '6fr'
    | '7fr'
    | '8fr'
    | '9fr'
    | '10fr';
  maxWidth?: number;
  minWidth?: number;
  renderHeaderCell?: TableRenderHeaderCell;
  isSeparator?: boolean;
  pinned?: TableColumnPropPinned;
  renderCell?: TableRenderCell<ROW>;
  colSpan?: TabletColSpan<ROW>;
  accessor?: string;
  columns?: TableColumn<ROW>[];
};

type TableRowMouseEvent<ROW> = (
  row: ROW,
  props: { e: React.MouseEvent },
) => void;

type GetRowKey<ROW> = (row: ROW) => string | number;
```

| Свойство           | Тип                           | По умолчанию      | Описание                                                     |
| ------------------ | ----------------------------- | ----------------- | ------------------------------------------------------------ |
| `columns?`         | `TableColumn[]`               | -                 | Колонки                                                      |
| `rows?`            | `ROW[]`                       | -                 | Строки                                                       |
| `getRowKey?`       | `GetRowKey<ROW>`              | `(row) => row.id` | Функция получения ключа, если ключ не найден берется `index` |
| `onRowMouseEnter?` | `TableRowMouseEvent<ROW>`     | -                 | Событие `onMouseEnter` на строке                             |
| `onRowMouseLeave?` | `TableRowMouseEvent<ROW>`     | -                 | Событие `onMouseLeave` на строке                             |
| `onRowClick?`      | `TableRowMouseEvent<ROW>`     | -                 | Событие `onClick` на строке                                  |
| `virtualScroll?`   | `boolean`                     | -                 | Включение виртуальной прокрутки                              |
| `stickyHeader?`    | `boolean`                     | -                 | Зафиксировать шапку сверху                                   |
| `resizable?`       | `'inside'` &#124; `'outside'` | -                 | Включение возможности изменять ширину колонок                |
| `zebraStriped?`    | `boolean`                     | -                 | Окрашивание строк через одну                                 |
| `headerZIndex?`    | `number`                      | `1`               | `zIndex` шапки                                               |
| `rowHoverEffect?`  | `boolean`                     | -                 | Включает эффект наведения на строку                          |
| `className?`       | `string`                      | -                 | Дополнительный CSS-класс                                     |
| `ref?`             | `React.Ref<HTMLDivElement>`   | -                 | Ссылка на корневой DOM-элемент                               |

## Колонка

Колонки формируются с помощью CSS-свойств `display: grid` и `grid-template-columns`.

```ts
export type TableColumn<ROW> = {
  title?: string;
  width?:
    | number
    | 'auto'
    | '1fr'
    | '2fr'
    | '3fr'
    | '4fr'
    | '5fr'
    | '6fr'
    | '7fr'
    | '8fr'
    | '9fr'
    | '10fr';
  maxWidth?: number;
  minWidth?: number;
  renderHeaderCell?: TableRenderHeaderCell;
  isSeparator?: boolean;
  pinned?: TableColumnPropPinned;
  renderCell?: TableRenderCell<ROW>;
  colSpan?: TabletColSpan<ROW>;
  accessor?: string;
  columns?: TableColumn<ROW>[];
};
```

| Свойство колонки                                             | Описание                                                                   |
| ------------------------------------------------------------ | -------------------------------------------------------------------------- |
| [`width`](#ширина-колонки)                                   | Ширина колонки, можно указать число, а также `'auto'` и значение в `'*fr'` |
| `maxWidth`                                                   | Максимальная ширина колонки                                                |
| `minWidth`                                                   | Минимальная ширина колонки                                                 |
| [`isSeparator`](#разделитель-колонок)                        | При включении колонка становится разделителем                              |
| `title`                                                      | Заголовок колонки                                                          |
| [`pinned`](#закрепление-колонок)                             | Закрепление колонки слева или справа                                       |
| [`renderCell`](#представление-данных-в-ячейке)               | Функция(компонент) для вывода данных ячейки                                |
| [`renderHeaderCell`](#представление-данных-в-ячейке-в-шапке) | Функция(компонент) для вывода данных ячейки в шапке                        |
| `accessor`                                                   | Уникальный указатель содержимого для каждой колонки                        |
| `columns`                                                    | Вложенные колонки                                                          |
| [`colSpan`](#объединение-ячеек)                              | Функция для вывода количества занятых колонок ячейкой                      |

## Ширина колонки

Для настройки ширины колонок используйте `width`, `maxWidth`, `minWidth`, где `width` — это желаемая ширина колонки. Если все колонки будут помещаться в таблицу без скролла, она останется неизменной. Чтобы таблица не уменьшала или не увеличивала колонку вне желаемых размеров, ограничьте ее, используя `maxWidth` и `minWidth`.

К примеру, если требуется зафиксировать размер первой колонки на `180px`, вторая и третья должны быть одинаковыми, но третья должна быть не меньше `150px`.

<MdxTabs>

<TableExampleWidth />

```tsx
import { Table, TableColumn } from '@consta/table/Table';

type Row = { name: string; profession: string; status: string };

const rows: Row[] = [
  {
    name: 'Антон',
    profession: 'Строитель, который построил дом',
    status: 'недоступен',
  },
  {
    name: 'Василий',
    profession: 'Отвечает на вопросы, хотя его не спросили',
    status: 'на связи',
  },
];

const columns: TableColumn<Row>[] = [
  {
    title: 'Имя',
    accessor: 'name',
    width: 180,
  },
  {
    title: 'Профессия',
    accessor: 'profession',
    width: '1fr',
  },
  {
    title: 'Статус',
    accessor: 'status',
    width: '1fr',
    minWidth: 150,
  },
];

export const TableExampleWidth = () => <Table rows={rows} columns={columns} />;
```

</MdxTabs>

### Разделитель колонок

Чтобы поставить разделитель колонки, вам необходимо указать еще одну колонку с указанием `{isSeparator: true}` и при необходимости указать `title`.

<MdxTabs>

<TableExampleSeparator />

```tsx
import { Table, TableColumn } from '@consta/table/Table';

type Row = { name: string; profession: string; status: string };

const rows: Row[] = [
  {
    name: 'Антон',
    profession: 'Строитель, который построил дом',
    status: 'недоступен',
  },
  {
    name: 'Василий',
    profession: 'Отвечает на вопросы, хотя его не спросили',
    status: 'на связи',
  },
];

const columns: TableColumn<Row>[] = [
  {
    title: 'Имя',
    accessor: 'name',
  },
  {
    title: 'Разделитель',
    isSeparator: true,
  },
  {
    title: 'Профессия',
    accessor: 'profession',
  },
  {
    isSeparator: true,
  },
  {
    title: 'Статус',
    accessor: 'status',
  },
];

export const TableExampleWidth = () => <Table rows={rows} columns={columns} />;
```

</MdxTabs>

### Закрепление колонок

Если в таблице есть горизонтальный скролл, вы можете закрепить несколько колонок справа или слева, используя свойство `pinned`.

<MdxInformer status="normal">

Закрепленные колонки (`pinned`) не могут изменять размер.

</MdxInformer>

<MdxTabs>

<TableExamplePinned />

```tsx
import { Table, TableColumn } from '@consta/table/Table';

type Row = {
  name: string;
  profession: string;
  status: string;
  phone: string;
  grade: number;
};

const rows: Row[] = [
  {
    name: 'Антон',
    profession: 'Строитель, который построил дом',
    status: 'недоступен',
    phone: '+7 976 543 21 00',
    grade: 3,
  },
  {
    name: 'Василий',
    profession: 'Отвечает на вопросы, хотя его не спросили',
    status: 'на связи',
    phone: '+7 976 543 21 00',
    grade: 3,
  },
];

const columns: TableColumn<Row>[] = [
  {
    title: 'Имя',
    accessor: 'name',
    pinned: 'left',
    minWidth: 180,
  },
  {
    title: 'Профессия',
    accessor: 'profession',
    minWidth: 360,
  },
  {
    title: 'Статус',
    accessor: 'status',
    minWidth: 200,
  },
  {
    title: 'Телефон',
    accessor: 'phone',
    minWidth: 260,
  },
  {
    title: 'Грейд',
    accessor: 'grade',
    pinned: 'right',
    minWidth: 80,
  },
];

export const TableExamplePinned = () => <Table rows={rows} columns={columns} />;
```

</MdxTabs>

### Группировка колонок

При необходимости объединить колонки в группу, вы можете вложить в колонку другие колонки, тем самым родитель будет группой колонок.

<MdxTabs>

<TableExampleGroupColumns />

```tsx
import { Table, TableColumn } from '@consta/table/Table';

type Row = {
  firstName: string;
  lastName: string;
  secondName: string;
  profession: string;
  status: string;
  phone: string;
  grade: number;
  email: string;
};

const rows: Row[] = [
  {
    firstName: 'Антон',
    lastName: 'Григорьев',
    secondName: 'Петров',
    profession: 'Строитель, который построил дом',
    status: 'недоступен',
    phone: '+7 976 543 21 00',
    email: 'anton@company.ru',
    grade: 3,
  },
  {
    firstName: 'Василий',
    lastName: 'Пупкин',
    secondName: 'Игоревич',
    profession: 'Отвечает на вопросы, хотя его не спросили',
    status: 'на связи',
    phone: '+7 976 543 21 00',
    email: 'vasya@company.ru',
    grade: 3,
  },
];

const columns: TableColumn<Row>[] = [
  {
    title: 'Работник',
    columns: [
      {
        title: 'Фамилия',
        accessor: 'lastName',
        minWidth: 140,
      },
      {
        title: 'Имя',
        accessor: 'firstName',
        minWidth: 140,
      },
      {
        title: 'Отчество',
        accessor: 'secondName',
        minWidth: 140,
      },
    ],
  },
  {
    title: 'Профессия',
    accessor: 'profession',
    minWidth: 200,
  },
  {
    title: 'Статус',
    accessor: 'status',
    minWidth: 140,
  },
  {
    title: 'Грейд',
    accessor: 'grade',
    minWidth: 80,
  },
  {
    title: 'Контакты',
    columns: [
      {
        title: 'Телефон',
        accessor: 'phone',
        minWidth: 200,
      },
      {
        title: 'e-mail',
        accessor: 'email',
        minWidth: 200,
      },
    ],
  },
];

export const TableExampleGroupColumns = () => (
  <Table rows={rows} columns={columns} />
);
```

</MdxTabs>

### Представление данных в ячейке

По умолчанию компонент таблицы пытается привести данные к строке и выводит их через компонент [`DataCell`](##LIBS.LIB.STAND/lib:table/stand:components-datacell-stable). Вы можете в колонке использовать свойство `renderCell` и выводить данные, как вам потребуется.

<MdxTabs>

<TableExampleRenderCell />

```tsx
import { Badge, BadgePropStatus } from '@consta/uikit/Badge';
import { Checkbox } from '@consta/uikit/Checkbox';
import { useFlag } from '@consta/uikit/useFlag';
import React from 'react';

import { DataCell } from '@consta/table/DataCell';
import { Table, TableColumn, TableRenderCell } from '@consta/table/Table';

type ROW = {
  name: string;
  profession: string;
  status: 'not available' | 'available';
};

const rows: ROW[] = [
  {
    name: 'Антон Григорьев',
    profession: 'Строитель, который построил дом',
    status: 'not available',
  },
  {
    name: 'Василий Пупкин',
    profession: 'Отвечает на вопросы, хотя его не спросили',
    status: 'available',
  },
];

const DataCellName: TableRenderCell<ROW> = (props) => {
  const [checked, setChecked] = useFlag();
  return (
    <DataCell
      control={
        <Checkbox size="s" checked={checked} onChange={setChecked.toggle} />
      }
    >
      {props.row.name}
    </DataCell>
  );
};

const mapBadgeProps: Record<
  ROW['status'],
  { status: BadgePropStatus; label: string }
> = {
  'available': {
    status: 'success',
    label: 'на связи',
  },
  'not available': {
    status: 'warning',
    label: 'недоступен',
  },
};

const DataCellStatus: TableRenderCell<ROW> = (props) => {
  return (
    <DataCell>
      <Badge {...mapBadgeProps[props.row.status]} />
    </DataCell>
  );
};

const columns: TableColumn<ROW>[] = [
  {
    title: 'Имя',
    accessor: 'name',
    width: 240,
    renderCell: DataCellName,
  },
  {
    title: 'Профессия',
    accessor: 'profession',
    width: '1fr',
  },
  {
    title: 'Статус',
    accessor: 'status',
    width: '1fr',
    minWidth: 150,
    renderCell: DataCellStatus,
  },
];

export const TableExampleRenderCell = () => (
  <Example col={1}>
    <Table rows={rows} columns={columns} />
  </Example>
);
```

</MdxTabs>

### Представление данных в ячейке в шапке

По умолчанию компонент таблицы пытается привести данные к строке и выводит их через компонент [`HeaderDataCell`](##LIBS.LIB.STAND/lib:table/stand:components-headerdatacell-stable).
Вы можете в колонке использовать свойство `renderHeaderCell` и выводить данные, как вам потребуется.

<MdxTabs>

<TableExampleRenderHeaderCell />

```tsx
import { IconFunnel } from '@consta/icons/IconFunnel';
import { IconKebab } from '@consta/icons/IconKebab';
import { IconUnsort } from '@consta/icons/IconUnsort';

import { Button } from '@consta/uikit/Button';
import React from 'react';

import { HeaderDataCell } from '@consta/table/HeaderDataCell';
import { Table, TableColumn, TableRenderHeaderCell } from '@consta/table/Table';

type ROW = {
  name: string;
  profession: string;
  status: string;
};

const rows: ROW[] = [
  {
    name: 'Антон Григорьев',
    profession: 'Строитель, который построил дом',
    status: 'недоступен',
  },
  {
    name: 'Василий Пупкин',
    profession: 'Отвечает на вопросы, хотя его не спросили',
    status: 'на связи',
  },
];

const DataHeaderCell: TableRenderHeaderCell = ({ title }) => {
  return (
    <HeaderDataCell
      controlRight={[
        <Button size="s" view="clear" iconLeft={IconUnsort} onlyIcon />,
        <Button size="s" view="clear" iconLeft={IconFunnel} onlyIcon />,
        <Button size="s" view="clear" iconLeft={IconKebab} onlyIcon />,
      ]}
    >
      {title}
    </HeaderDataCell>
  );
};

const columns: TableColumn<ROW>[] = [
  {
    title: 'Имя',
    accessor: 'name',
    width: 240,
    renderHeaderCell: DataHeaderCell,
  },
  {
    title: 'Профессия',
    accessor: 'profession',
    width: '1fr',
    renderHeaderCell: DataHeaderCell,
  },
  {
    title: 'Статус',
    accessor: 'status',
    width: '1fr',
    minWidth: 150,
    renderHeaderCell: DataHeaderCell,
  },
];

export const TableExampleRenderHeaderCell = () => (
  <Table rows={rows} columns={columns} />
);
```

</MdxTabs>

### Объединение ячеек

Чтобы объединить несколько колонок в одной ячейке, используйте свойство `colSpan` в объекте колонки (columns). `colSpan` — это функция, которая возвращает одно из следующих значений:

- `number` — количество колонок, которое должна занимать ячейка.
- `end` — ячейка растянется до конца строки, захватывая все оставшиеся колонки.
- `undefined` — ячейка займет только одну колонку (эквивалентно 1).

<MdxInformer status="warning">

Если вы используете закрепление колонок, убедитесь, что объединённые ячейки не входят в закреплённую область.

</MdxInformer>

<MdxTabs>

<TableExampleColSpan />

```tsx
import { AnimateIconSwitcherProvider } from '@consta/icons/AnimateIconSwitcherProvider';
import { IconArrowRight } from '@consta/icons/IconArrowRight';
import { withAnimateSwitcherHOC } from '@consta/icons/withAnimateSwitcherHOC';
import { Example } from '@consta/stand';
import { Button } from '@consta/uikit/Button';
import { useMutableRef } from '@consta/uikit/useMutableRef';
import React, { useCallback, useMemo, useState } from 'react';

import { DataCell } from '@consta/table/DataCell';
import { Table, TableColumn, TableRenderCell } from '@consta/table/Table';

const IconArrow = withAnimateSwitcherHOC({
  startIcon: IconArrowRight,
  startDirection: 0,
  endDirection: 90,
});

type HUMAN = {
  name: string;
  age: number;
  street: string;
  building: number;
  number: number;
  gender: string;
  district: string;
};

type GROUP = {
  district: string;
  name: undefined;
  age: undefined;
  street: undefined;
  building: undefined;
  number: undefined;
  gender: undefined;
};

const data: (HUMAN | GROUP)[] = [
  {
    name: undefined,
    age: undefined,
    street: undefined,
    building: undefined,
    number: undefined,
    gender: undefined,
    district: 'Ленинский район',
  },
  {
    name: 'Иван',
    street: 'ул. Мира',
    building: 1,
    age: 32,
    number: 2033,
    gender: 'муж.',
    district: 'Ленинский район',
  },
  {
    name: 'Анна',
    age: 40,
    street: 'пл. Ленина',
    building: 3,
    number: 2035,
    gender: 'жен.',
    district: 'Ленинский район',
  },
];

const DataCellGroup = (props: {
  district: string;
  opened: boolean | undefined;
  toggle: (idx: string) => void;
}) => {
  const { district, opened, toggle } = props;

  return (
    <AnimateIconSwitcherProvider active={opened}>
      <DataCell
        control={
          <Button
            size="s"
            view="clear"
            iconLeft={IconArrow}
            onlyIcon
            onClick={() => toggle(district)}
          />
        }
      >
        Граждане
      </DataCell>
    </AnimateIconSwitcherProvider>
  );
};

export const TableExampleColSpan = () => {
  const [openedList, setOpenedList] = useState<string[]>([]);

  const openedListRef = useMutableRef(openedList);

  const rows = useMemo(() => {
    return data.filter(
      (dataItem) =>
        dataItem.name === undefined ||
        openedList.findIndex(
          (openedListItem) => openedListItem === dataItem.district,
        ) !== -1,
    );
  }, [openedList]);

  const toggle = useCallback((idx: string) => {
    setOpenedList((state) => {
      const open = state.findIndex((value) => value === idx) !== -1;
      if (open) {
        return state.filter((value) => value !== idx);
      }
      return [...state, idx];
    });
  }, []);

  const renderNameCell: TableRenderCell<HUMAN | GROUP> = useCallback(
    (props) =>
      props.row.name ? (
        <DataCell>{props.row.name}</DataCell>
      ) : (
        <DataCellGroup
          toggle={toggle}
          district={props.row.district}
          opened={
            openedListRef.current.findIndex(
              (item) => item === props.row.district,
            ) !== -1
          }
        />
      ),
    [],
  );

  const renderStreetCell: TableRenderCell<HUMAN | GROUP> = useCallback(
    (props) =>
      props.row.street ? (
        <DataCell>{props.row.street}</DataCell>
      ) : (
        <DataCell>{props.row.district}</DataCell>
      ),
    [],
  );

  const columns: TableColumn<GROUP | HUMAN>[] = useMemo(
    () => [
      {
        title: 'Имя',
        accessor: 'name',
        width: 150,
        renderCell: renderNameCell,
        colSpan: ({ row }) => (row.name ? 1 : 2),
        minWidth: 100,
      },
      {
        title: 'Возраст',
        accessor: 'age',
        minWidth: 100,
      },
      {
        title: 'Адрес',
        columns: [
          {
            title: 'Улица',
            accessor: 'street',
            renderCell: renderStreetCell,
            colSpan: ({ row }) => (row.street ? 1 : 3),
            minWidth: 100,
          },
          {
            title: 'Дом',
            accessor: 'building',
            minWidth: 100,
          },
          {
            title: 'Квартира',
            accessor: 'number',
            minWidth: 100,
          },
        ],
      },
      {
        title: 'Пол',
        accessor: 'gender',
        minWidth: 80,
      },
    ],
    [],
  );

  return (
    <Table
      style={{ maxHeight: 400 }}
      rows={rows}
      columns={columns}
      stickyHeader
      zebraStriped
      getRowKey={(row) => row.district + row.name + row.age}
    />
  );
};
```

</MdxTabs>

## Закрепление шапки

Чтобы закрепить шапку, используйте свойство `stickyHeader` и ограничьте высоту таблицы в свойстве `maxHeight`.

<MdxTabs>

```tsx
<Table style={{ maxHeight: 400 }} rows={rows} columns={columns} stickyHeader />
```

<TableExampleStickyHeader />

</MdxTabs>

## Виртуальный скролл

Если в таблице много данных, включите свойство `virtualScroll` и ограничьте высоту таблицы для лучшей производительности. Может принимать два значения:

- `boolean` – будет включен виртуальный скролл по горизонтали и вертикали,
- `[boolean, boolean]` – первый элемент определяет, включается ли виртуальный скролл по горизонтали, второй – по вертикали.

<MdxInformer>

Чтобы избежать скачков строки при включении виртуального скролла, задайте одинаковую высоту ячеек в строке.

</MdxInformer>

<MdxTabs>

```tsx
<Table
  style={{ maxHeight: 400 }}
  rows={rows}
  columns={columns}
  stickyHeader
  virtualScroll
/>
```

<TableExampleVirtualScroll />

</MdxTabs>

## Таблица в полоску

Для отображения таблицы в полоску используйте `zebraStriped`.

<MdxTabs>

```tsx
<Table
  style={{ maxHeight: 400 }}
  rows={rows}
  columns={columns}
  stickyHeader
  virtualScroll
  zebraStriped
/>
```

<TableExampleZebraStriped />

</MdxTabs>

## Выделение строк

Строки могут иметь состояние:

- Наведение на строку – [`hover`](#наведение-на-строку),
- Выбор строки - [`active`](#выбор-строки)

<MdxInformer status="success">

Чтобы не рендерить всю таблицу при каждом изменении данных в ячейке, используйте [стейт-менеджер](https://www.reatom.dev/blog/what-is-state-manager/) или [контекст](https://react.dev/reference/react/createContext).

</MdxInformer>

Пример с наведением и выбором строки:

<MdxTabs>

<TableExampleActiveRowWithNumbering />

```tsx
import { Example } from '@consta/stand';
import { action, atom, AtomMut } from '@reatom/core';
import { useAction, useAtom } from '@reatom/npm-react';
import React from 'react';

import { DataCell } from '##/components/DataCell';
import { DataNumberingCell } from '##/components/DataNumberingCell';
import { Table, TableColumn, TableRenderCell } from '##/components/Table';

// Types

type ROW = {
  id: number;
  name: string;
  profession: string;
  status: string;
  hover: AtomMut<boolean>;
  active: AtomMut<boolean>;
};

// Atoms
const rowsAtom = atom<AtomMut<ROW>[]>([
  atom({
    id: 1,
    name: 'Антон Григорьев',
    profession: 'Строитель, который построил дом',
    status: 'недоступен',
    hover: atom(false),
    active: atom(false),
  }),
  atom({
    id: 2,
    name: 'Василий Пупкин',
    profession: 'Отвечает на вопросы, хотя его не спросили',
    status: 'на связи',
    hover: atom(false),
    active: atom(false),
  }),
]);

// Actions

const onRowClickAction = action<[AtomMut<ROW>]>((ctx, rowAtom) => {
  const row = ctx.get(rowAtom);
  row.active(ctx, !ctx.get(row.active));
});

const onRowMouseEnterAction = action<[AtomMut<ROW>]>((ctx, rowAtom) => {
  ctx.get(rowAtom).hover(ctx, true);
});

const onRowMouseLeaveAction = action<[AtomMut<ROW>]>((ctx, rowAtom) => {
  ctx.get(rowAtom).hover(ctx, false);
});

const DataCellName: TableRenderCell<AtomMut<ROW>> = (props) => {
  const [row] = useAtom(props.row);
  const [active] = useAtom(row.active);
  const [hover] = useAtom(row.hover);

  return (
    <DataNumberingCell data-row-active={active} data-row-hover={hover}>
      {row.id}
    </DataNumberingCell>
  );
};

const createDataCellOther = (
  accessor: Exclude<keyof ROW, 'hover' | 'active'>,
) => {
  const Component: TableRenderCell<AtomMut<ROW>> = (props) => {
    const [row] = useAtom(props.row);

    return <DataCell>{row[accessor]}</DataCell>;
  };

  return Component;
};

const columns: TableColumn<AtomMut<ROW>>[] = [
  {
    title: '',
    accessor: 'id',
    width: 48,
    maxWidth: 48,
    minWidth: 48,
    renderCell: DataCellName,
  },
  {
    title: 'Имя',
    accessor: 'name',
    width: 240,
    renderCell: createDataCellOther('name'),
  },
  {
    title: 'Профессия',
    accessor: 'profession',
    width: '1fr',
    renderCell: createDataCellOther('profession'),
  },
  {
    title: 'Статус',
    accessor: 'status',
    width: '1fr',
    minWidth: 150,
    renderCell: createDataCellOther('status'),
  },
];

export const TableExampleActiveRowWithNumbering = () => {
  const onRowClick = useAction(onRowClickAction);
  const onRowMouseEnter = useAction(onRowMouseEnterAction);
  const onRowMouseLeave = useAction(onRowMouseLeaveAction);
  const [rows] = useAtom(rowsAtom);

  return (
    <Example col={1}>
      <Table
        rows={rows}
        columns={columns}
        zebraStriped
        onRowClick={onRowClick}
        onRowMouseEnter={onRowMouseEnter}
        onRowMouseLeave={onRowMouseLeave}
      />
    </Example>
  );
};
```

</MdxTabs>

### Наведение на строку

Есть 2 способа задать состояние `hover` строкам:

- Автоматически, с помощью Свойства `rowHoverEffect`. В этом случае все строки будут подсвечиваться при наведении мыши.

Пример автоматического способа:

<MdxTabs>

<TableExampleRowHoverEffect />

```tsx
import React from 'react';

import { Table, TableColumn } from '@consta/table/Table';
import rows from '##/components/Table/__mocks__/olympic-winners.json';

type ROW = {
  athlete: string;
  age: number | null;
  country: string;
  year: number;
  date: string;
  sport: string;
  gold: number;
  silver: number;
  bronze: number;
  total: number;
};

const columns: TableColumn<ROW>[] = [
  {
    title: 'Имя',
    width: 'auto',
    accessor: 'athlete',
  },
  {
    title: 'Страна',
    accessor: 'country',
    width: 'auto',
  },
  {
    title: 'Возраст',
    accessor: 'age',
    minWidth: 100,
  },
];

export const TableExampleRowHoverEffect = () => (
  <Table
    style={{ maxHeight: 400 }}
    rows={rows}
    columns={columns}
    stickyHeader
    virtualScroll
    rowHoverEffect
  />
);
```

</MdxTabs>

- Подконтрольный. Для этого нужно у любой ячейки в строке указать атрибут `data-row-hover='true'`. В этом режиме вы можете выбирать, у каких строк включить этот эффект а у каких нет.

Пример подконтрольного способа:

<MdxTabs>

<TableExampleHoveredControlled />

```tsx
import { action, atom } from '@reatom/core';
import { useAction, useAtom } from '@reatom/npm-react';
import React from 'react';

import { DataNumberingCell } from '@consta/table/DataNumberingCell';
import { Table, TableColumn, TableRenderCell } from '@consta/table/Table';

// Types

type ROW = {
  id: number;
  name: string;
  profession: string;
  status: string;
};

const rows: ROW[] = [
  {
    id: 1,
    name: 'Антон Григорьев',
    profession: 'Строитель, который построил дом',
    status: 'недоступен',
  },
  {
    id: 2,
    name: 'Василий Пупкин',
    profession: 'Отвечает на вопросы, хотя его не спросили',
    status: 'на связи',
  },
];

// Atoms

const hoverIdAtom = atom<ROW['id'] | undefined>(undefined);

// Actions

const onRowMouseEnterAction = action<[ROW]>((ctx, row) =>
  hoverIdAtom(ctx, row.id),
);

const onRowMouseLeaveAction = action<[ROW]>((ctx, row) => {
  const hoverId = ctx.get(hoverIdAtom);
  if (hoverId === row.id) {
    hoverIdAtom(ctx, undefined);
  }
});

const DataCellName: TableRenderCell<ROW> = (props) => {
  const [hover] = useAtom((ctx) => {
    const hoverId = ctx.spy(hoverIdAtom);
    return hoverId === props.row.id;
  });

  return (
    <DataNumberingCell data-row-hover={hover}>{props.row.id}</DataNumberingCell>
  );
};

const columns: TableColumn<ROW>[] = [
  {
    title: '',
    accessor: 'id',
    width: 48,
    maxWidth: 48,
    minWidth: 48,
    renderCell: DataCellName,
  },
  {
    title: 'Имя',
    accessor: 'name',
    width: 240,
  },
  {
    title: 'Профессия',
    accessor: 'profession',
    width: '1fr',
  },
  {
    title: 'Статус',
    accessor: 'status',
    width: '1fr',
    minWidth: 150,
  },
];

export const TableExampleHoveredControlled = () => {
  const onRowMouseEnter = useAction(onRowMouseEnterAction);
  const onRowMouseLeave = useAction(onRowMouseLeaveAction);

  return (
    <Table
      rows={rows}
      columns={columns}
      zebraStriped
      onRowMouseEnter={onRowMouseEnter}
      onRowMouseLeave={onRowMouseLeave}
      rowHoverEffect
    />
  );
};
```

</MdxTabs>

### Выбор строки

Для выбора строки укажите в любой ячейке строки атрибут `data-row-active='true'`.

Пример с использованием стейт-менеджера:

<MdxTabs>

<TableExampleActiveRow />

```tsx
import { Example } from '@consta/stand';
import { Checkbox } from '@consta/uikit/Checkbox';
import { atom, AtomMut } from '@reatom/core';
import { useAction, useAtom } from '@reatom/npm-react';
import React from 'react';

import { DataCell } from '##/components/DataCell';
import { Table, TableColumn, TableRenderCell } from '##/components/Table';

type ROW = {
  id: number;
  name: string;
  profession: string;
  status: string;
};

const activeIdsAtom = atom<Record<ROW['id'], AtomMut<boolean>>>({});

const DataCellName: TableRenderCell<ROW> = (props) => {
  const [active] = useAtom((ctx) => {
    const activeAtom = ctx.spy(activeIdsAtom)[props.row.id];
    return activeAtom ? ctx.spy(activeAtom) : false;
  });

  const onChange = useAction((ctx) => {
    const activeIds = ctx.get(activeIdsAtom);
    const activeAtom = ctx.get(activeIdsAtom)[props.row.id];

    if (activeAtom) {
      activeAtom(ctx, !ctx.get(activeAtom));
    } else {
      activeIdsAtom(ctx, { ...activeIds, [props.row.id]: atom(true) });
    }
  });

  return (
    <DataCell
      data-row-active={active}
      control={<Checkbox size="s" checked={active} onChange={onChange} />}
    >
      {props.row.name}
    </DataCell>
  );
};

const columns: TableColumn<ROW>[] = [
  {
    title: 'Имя',
    accessor: 'name',
    width: 240,
    renderCell: DataCellName,
  },
  {
    title: 'Профессия',
    accessor: 'profession',
    width: '1fr',
  },
  {
    title: 'Статус',
    accessor: 'status',
    width: '1fr',
    minWidth: 150,
  },
];

const rows: ROW[] = [
  {
    id: 1,
    name: 'Антон Григорьев',
    profession: 'Строитель, который построил дом',
    status: 'недоступен',
  },
  {
    id: 2,
    name: 'Василий Пупкин',
    profession: 'Отвечает на вопросы, хотя его не спросили',
    status: 'на связи',
  },
];

export const TableExampleActiveRow = () => (
  <Example col={1}>
    <Table rows={rows} columns={columns} zebraStriped />
  </Example>
);
```

</MdxTabs>

## Управление шириной столбцов

Чтобы дать пользователю возможность управлять шириной столбцов, используйте свойство `resizable`. Уменьшение и увеличение будет в пределах `minWidth` и `maxWidth` у колонки.

<MdxInformer status="success">

Чтобы запретить изменение ширины у определенной колонки, установите у `minWidth` и `maxWidth` равное значение.

</MdxInformer>

Закрепленные колонки (`pinned`) не могут изменять размер.

Есть 2 режима работы:

- `inside`. При `resizable = 'inside'` таблица будет стараться уместить весь контент в ширину контейнера таблицы. То есть при увеличении ширины одного столбца будет уменьшаться ширина другого, и наоборот. Рекомендуется использовать этот режим, когда столбцов мало и они все помещаются в таблицу.

<MdxTabs>

<TableExampleResizableInside />

```tsx
import { Example } from '@consta/stand';
import React from 'react';

import { Table, TableColumn } from '@consta/table/Table';
import rows from '##/components/Table/__mocks__/olympic-winners.json';

type ROW = {
  athlete: string;
  age: number | null;
  country: string;
};

const columns: TableColumn<ROW>[] = [
  {
    title: 'Имя',
    width: 'auto',
    accessor: 'athlete',
    // Запретили менять ширину у колонки
    minWidth: 200,
    maxWidth: 200,
  },
  {
    title: 'Страна',
    accessor: 'country',
    width: 'auto',
    minWidth: 140,
  },
  {
    title: 'Возраст',
    accessor: 'age',
    width: 'auto',
    minWidth: 100,
  },
];

export const TableExampleResizable = () => (
  <Table
    style={{ maxHeight: 400 }}
    rows={rows}
    columns={columns}
    stickyHeader
    virtualScroll
    resizable="inside"
  />
);
```

</MdxTabs>

- `outside`. При `resizable = 'outside'` таблица будет расширятся при увеличении колонки. Рекомендуется использовать этот режим, когда столбцов много и они не помещаются в таблицу.

<MdxTabs>

<TableExampleResizableOutside />

```tsx
import { Example } from '@consta/stand';
import React from 'react';

import { Table, TableColumn } from '@consta/table/Table';
import rows from '##/components/Table/__mocks__/olympic-winners.json';

type ROW = {
  athlete: string;
  age: number | null;
  country: string;
};

const columns: TableColumn<ROW>[] = [
  {
    title: 'Имя',
    width: 'auto',
    accessor: 'athlete',
    minWidth: 200,
  },
  {
    title: 'Страна',
    accessor: 'country',
    width: 'auto',
    minWidth: 140,
    pinned: 'left',
  },
  {
    title: 'Возраст',
    accessor: 'age',
    width: 'auto',
    minWidth: 100,
  },
  {
    title: 'Медали',
    columns: [
      {
        title: 'Бронза',
        accessor: 'bronze',
        width: 'auto',
        minWidth: 100,
      },
      {
        title: 'Серебро',
        accessor: 'silver',
        width: 'auto',
        minWidth: 100,
      },
      {
        title: 'Золото',
        accessor: 'gold',
        width: 'auto',
        minWidth: 100,
      },
      {
        title: 'Всего',
        accessor: 'total',
        width: 'auto',
        minWidth: 100,
      },
    ],
  },
  {
    title: 'Год',
    accessor: 'year',
    width: 'auto',
    minWidth: 140,
    pinned: 'right',
  },
];

export const TableExampleResizableOutside = () => (
  <Table
    style={{ maxHeight: 400 }}
    rows={rows}
    columns={columns}
    stickyHeader
    virtualScroll
    resizable="outside"
    zebraStriped
  />
);
```

</MdxTabs>

## headerZIndex

Свойство `headerZIndex` влияет на [`z-index`](https://developer.mozilla.org/ru/docs/Web/CSS/z-index) следующих элементов:

- Шапка таблицы.
- Ячейки в закрепленных колонках `z-index: calc(var(--table-header-z-index) - 1)`.
- Ячейки в закрепленных колонках в шапке `z-index: calc(var(--table-header-z-index) + 1)`.
- Ресайзеры колонок `z-index: calc(var(--table-header-z-index) + 10)`.

<MdxInformer status="success">

Если вы используете всплывающие окна (`Popover`, `Tooltip`), привязывайте их `z-index` к переменной `--table-header-z-index`.  
Например: `z-index: calc(var(--table-header-z-index) + 1)`. Таким образом плавающий элемент будет находится под шапкой таблицы.

</MdxInformer>

## Вложенные строки

Реализовать вложенные строки возможно через `renderCell` у колонки, взяв компонент [`DataCell`](##LIBS.LIB.STAND/lib:table/stand:components-datacell-stable) и назначив ему свойство `level`.

<MdxTabs>

<TableExampleNestedRows />

```tsx
import { AnimateIconSwitcherProvider } from '@consta/icons/AnimateIconSwitcherProvider';
import { IconArrowRight } from '@consta/icons/IconArrowRight';
import { withAnimateSwitcherHOC } from '@consta/icons/withAnimateSwitcherHOC';
import { Button } from '@consta/uikit/Button';
import { useMutableRef } from '@consta/uikit/useMutableRef';
import React, { useCallback, useMemo, useState } from 'react';

import { DataCell } from '@consta/table/DataCell';
import { Table, TableColumn, TableRenderCell } from '@consta/table/Table';
import { range } from '##/utils/array';

type ROW = {
  idx: number;
  col1: string;
  col2: string;
  col3: string;
  parent: number | undefined;
  level: number;
};

const IconArrow = withAnimateSwitcherHOC({
  startIcon: IconArrowRight,
  startDirection: 0,
  endDirection: 90,
});

const getDataCell = (idx: number): ROW => {
  const parent = Math.floor(idx / 10) * 10;

  return {
    idx,
    col1: `Данные 1 - ${idx}`,
    col2: `Данные 2 - ${idx}`,
    col3: `Данные 3 - ${idx}`,
    parent: parent === idx ? undefined : parent,
    level: parent === idx ? 0 : 1,
  };
};

const data = range(100000).map(getDataCell);

const DataCellCol1 = (props: {
  row: {
    col1: string;
    parent: number | undefined;
    idx: number;
    level: number;
  };
  opened: boolean | undefined;
  toggle: (idx: number) => void;
}) => {
  const {
    row: { col1, parent, idx, level },
    opened,
    toggle,
  } = props;

  return (
    <AnimateIconSwitcherProvider active={opened}>
      <DataCell
        level={level}
        control={
          typeof parent === 'undefined' ? (
            <Button
              size="s"
              view="clear"
              iconLeft={IconArrow}
              onlyIcon
              onClick={() => toggle(idx)}
            />
          ) : undefined
        }
      >
        {col1}
      </DataCell>
    </AnimateIconSwitcherProvider>
  );
};

export const TableExampleNestedRows = () => {
  const [openedList, setOpenedList] = useState<number[]>([]);

  const openedListRef = useMutableRef(openedList);

  const rows = useMemo(() => {
    return data.filter(
      (dataItem) =>
        dataItem.parent === undefined ||
        openedList.findIndex(
          (openedListItem) => openedListItem === dataItem.parent,
        ) !== -1,
    );
  }, [openedList]);

  const toggle = useCallback((idx: number) => {
    setOpenedList((state) => {
      const open = state.findIndex((value) => value === idx) !== -1;
      if (open) {
        return state.filter((value) => value !== idx);
      }
      return [...state, idx];
    });
  }, []);

  const renderCellCol1: TableRenderCell<ROW> = useCallback(
    (props) => (
      <DataCellCol1
        {...props}
        toggle={toggle}
        opened={
          openedListRef.current.findIndex((item) => item === props.row.idx) !==
          -1
        }
      />
    ),
    [],
  );

  const columns: TableColumn<ROW>[] = useMemo(
    () => [
      {
        title: 'Колонка - 1',
        accessor: 'col1',
        renderCell: renderCellCol1,
      },
      {
        title: 'Колонка - 2',
        accessor: 'col2',
      },
      {
        title: 'Колонка - 3',
        accessor: 'col3',
      },
    ],
    [],
  );

  return (
    <Table
      style={{ maxHeight: 400 }}
      rows={rows}
      columns={columns}
      stickyHeader
      virtualScroll
      getRowKey={(row) => row.idx}
    />
  );
};
```

</MdxTabs>

## Рендер строки

Чтобы вывести всю строку с собственным представлением, укажите у первого столбца `colSpan = () => 'end'`, и `renderCell`.

<MdxTabs>

<TableExampleRenderRow />

```tsx
import { AnimateIconSwitcherProvider } from '@consta/icons/AnimateIconSwitcherProvider';
import { IconArrowRight } from '@consta/icons/IconArrowRight';
import { withAnimateSwitcherHOC } from '@consta/icons/withAnimateSwitcherHOC';
import { Example } from '@consta/stand';
import { Button } from '@consta/uikit/Button';
import { Grid, GridItem } from '@consta/uikit/Grid';
import { cnMixSpace } from '@consta/uikit/MixSpace';
import { Text } from '@consta/uikit/Text';
import { useMutableRef } from '@consta/uikit/useMutableRef';
import React, { useCallback, useMemo, useState } from 'react';

import { DataCell } from '##/components/DataCell';
import { Table, TableColumn, TableRenderCell } from '@consta/table/Table';

const IconArrow = withAnimateSwitcherHOC({
  startIcon: IconArrowRight,
  startDirection: 0,
  endDirection: 90,
});

type Option = { label: string; value: string };
type Options = { label: string; value: Option[] };

type Item = {
  id: number;
  label: string;
  formula: string;
  type: string;
};

type ItemInfo = {
  isInfo: number;
  options: Options[];
};

type Row = {
  id?: number;
  label?: string;
  formula?: string;
  type?: string;
  status?: 'work' | 'problem' | 'wait' | 'success';
  isInfo?: number;
  options?: Options[];
};

const data: Row[] = [
  {
    id: 1,
    label: 'Запись инклинометрии',
    formula: 'Время замера * Количество',
    type: 'Кондуктор',
  },
  {
    isInfo: 1,
    options: [
      {
        label: 'Порты',
        value: [
          { label: 'Входящий', value: 'A2-папа' },
          { label: 'Исходящий', value: 'A2-папа' },
        ],
      },
      {
        label: 'Размеры',
        value: [
          { label: 'ширина(мм)', value: '60' },
          { label: 'длинна(мм)', value: '80' },
        ],
      },
    ],
  },
  {
    id: 2,
    label: 'Шаблонирование при бурении',
    formula: 'Интервал/Скорость СПО',
    type: 'Труба бурильная',
  },
  {
    isInfo: 2,
    options: [
      {
        label: 'Диаметры',
        value: [
          { label: 'Внешний', value: '14.7' },
          { label: 'Внутренний', value: '12.7' },
        ],
      },
      {
        label: 'Нагрузка и моменты',
        value: [
          { label: 'Растягивающая нагрузка тела трубы, кН', value: '30' },
          { label: 'Допустимый момент на кручение ЗС,кН*м', value: '10' },
          {
            label: 'Допустимый момент на кручение тела трубы, кН*м',
            value: '10',
          },
          {
            label: 'Рекомендуемый момент свинчивания, кН*м',
            value: '10',
          },
        ],
      },
    ],
  },
];

const isItemInfo = (arg: Row): arg is ItemInfo =>
  Object.prototype.hasOwnProperty.call(arg, 'isInfo');

const isItem = (arg: Row): arg is Item =>
  Object.prototype.hasOwnProperty.call(arg, 'id');

const LabelCell = (props: {
  id: number;
  label: string;
  opened: boolean | undefined;
  toggle: (idx: number) => void;
}) => {
  const { id, opened, toggle, label } = props;

  return (
    <AnimateIconSwitcherProvider active={opened}>
      <DataCell
        control={
          <Button
            size="s"
            view="clear"
            iconLeft={IconArrow}
            onlyIcon
            onClick={() => toggle(id)}
          />
        }
      >
        {label}
      </DataCell>
    </AnimateIconSwitcherProvider>
  );
};

const InfoCell = (props: { options: Options[] }) => {
  const { options } = props;
  return (
    <Grid className={cnMixSpace({ p: 's' })} cols={4} gap="s">
      {options.map((opt) => {
        return (
          <>
            <GridItem col={4}>
              <Text weight="semibold">{opt.label}</Text>
            </GridItem>
            {opt.value.map((val) => (
              <GridItem>
                <Text>{val.value}</Text>
                <Text size="s" view="secondary">
                  {val.label}
                </Text>
              </GridItem>
            ))}
          </>
        );
      })}
    </Grid>
  );
};

export const TableExampleRenderRow = () => {
  const [openedList, setOpenedList] = useState<number[]>([]);

  const openedListRef = useMutableRef(openedList);

  const rows = useMemo(() => {
    return data.filter(
      (dataItem) =>
        Object.prototype.hasOwnProperty.call(dataItem, 'id') ||
        (isItemInfo(dataItem) &&
          openedList.findIndex(
            (openedListItem) => openedListItem === dataItem.isInfo,
          ) !== -1),
    );
  }, [openedList]);

  const toggle = useCallback((idx: number) => {
    setOpenedList((state) => {
      const open = state.findIndex((value) => value === idx) !== -1;
      if (open) {
        return state.filter((value) => value !== idx);
      }
      return [...state, idx];
    });
  }, []);

  const renderLabelCell: TableRenderCell<Row> = useCallback(({ row }) => {
    if (isItem(row)) {
      return (
        <LabelCell
          id={row.id}
          label={row.label}
          opened={openedListRef.current.findIndex((id) => id === row.id) !== -1}
          toggle={toggle}
        />
      );
    }
    if (isItemInfo(row)) {
      return <InfoCell options={row.options} />;
    }
    return null;
  }, []);

  const columns: TableColumn<Row>[] = useMemo(
    () => [
      {
        title: 'Название',
        accessor: 'label',
        renderCell: renderLabelCell,
        colSpan: ({ row }) => (isItemInfo(row) ? 'end' : 1),
        minWidth: 300,
      },
      {
        title: 'Формула',
        accessor: 'formula',
        minWidth: 200,
      },
      {
        title: 'Тип',
        accessor: 'type',
        minWidth: 180,
      },
    ],
    [],
  );

  return (
    <Table
      style={{ maxHeight: 500 }}
      rows={rows}
      columns={columns}
      stickyHeader
      getRowKey={(row) => {
        if (isItemInfo(row)) {
          return `${row.isInfo}-info`;
        }
        if (isItem(row)) {
          return `${row.id}`;
        }
        return '';
      }}
    />
  );
};
```

</MdxTabs>

## Индикатор ячейки и подсказки

Для отображения индикатора используйте свойство `indicator` у компонента `DataCell`. Для вывода подсказок используйте компонент `Popover`. В примере ниже реализована логика показа подсказок по наведению курсора.

Пример со всплывающими подсказками:

<MdxTabs>

<TableExampleWithIndicator />

```tsx
import { Example } from '@consta/stand';
import { Informer } from '@consta/uikit/Informer';
import {
  animateTimeout,
  cnMixPopoverAnimate,
} from '@consta/uikit/MixPopoverAnimate';
import { Popover } from '@consta/uikit/Popover';
import { useDebounce } from '@consta/uikit/useDebounce';
import { useFlag } from '@consta/uikit/useFlag';
import React, { useCallback, useRef } from 'react';
import { Transition } from 'react-transition-group';

import { DataCell } from '@consta/table/DataCell';
import { Table, TableColumn } from '@consta/table/Table';

type Cell<T> = {
  data: T;
  status?: 'alert' | 'warning';
  statusMessage?: string;
};

type Row = {
  name: Cell<string>;
  profession: Cell<string>;
  status: Cell<string>;
};

const rows: Row[] = [
  {
    name: {
      data: 'Антон',
    },
    profession: {
      data: 'РОЮЛАВТМЯО',
      status: 'alert',
      statusMessage: 'Неизвестное название диапазона: РОЮЛАВТМЯО.',
    },
    status: {
      data: 'недоступен',
    },
  },
  ..//..//..
];

const titleMap: Record<'alert' | 'warning', string> = {
  alert: 'Ошибка',
  warning: 'Предупреждение',
};

const DataCellWithInformer = ({
  data,
  tableRef,
  statusMessage,
  status,
}: {
  data: string;
  status?: 'alert' | 'warning';
  statusMessage?: string;
  tableRef: React.RefObject<HTMLDivElement>;
}) => {
  const cellRef = useRef<HTMLDivElement>(null);
  const popoverContentRef = useRef<HTMLDivElement>(null);
  const [informerVisible, setInformerVisible] = useFlag();

  const hoverStateRef = useRef<{
    popover: boolean;
    anchor: boolean;
  }>({
    popover: false,
    anchor: false,
  });

  const mouseEnterController = useDebounce(
    useCallback(() => {
      (hoverStateRef.current.anchor || hoverStateRef.current.popover) &&
        setInformerVisible.on();
    }, []),
    200,
  );

  const mouseLeaveController = useDebounce(
    useCallback(() => {
      !hoverStateRef.current.anchor &&
        !hoverStateRef.current.popover &&
        setInformerVisible.off();
    }, []),
    200,
  );

  const anchorOnMouseEnter: React.MouseEventHandler<HTMLDivElement> =
    useCallback((e) => {
      hoverStateRef.current.anchor = true;
      mouseEnterController();
    }, []);

  const anchorOnMouseLeave: React.MouseEventHandler<HTMLDivElement> =
    useCallback((e) => {
      hoverStateRef.current.anchor = false;
      mouseLeaveController();
    }, []);

  const popoverOnMouseEnter: React.MouseEventHandler<HTMLDivElement> =
    useCallback((e) => {
      hoverStateRef.current.popover = true;
      mouseEnterController();
    }, []);

  const popoverOnMouseLeave: React.MouseEventHandler<HTMLDivElement> =
    useCallback((e) => {
      hoverStateRef.current.popover = false;
      mouseLeaveController();
    }, []);

  return (
    <>
      <DataCell
        ref={cellRef}
        onClick={setInformerVisible.toggle}
        indicator={status}
        onMouseEnter={anchorOnMouseEnter}
        onMouseLeave={anchorOnMouseLeave}
      >
        {status === 'alert' ? '#ТИПДАННЫХ?' : data}
      </DataCell>
      {status && (
        <Transition
          in={informerVisible}
          unmountOnExit
          timeout={animateTimeout}
          nodeRef={popoverContentRef}
        >
          {(animate) => (
            <Popover
              className={cnMixPopoverAnimate({ animate })}
              viewportRef={tableRef}
              ref={popoverContentRef}
              anchorRef={cellRef}
              style={{
                zIndex: 'calc(var(--table-header-z-index) + 1)',
                maxWidth: 180,
              }}
              direction="leftStartUp"
              possibleDirections={[
                'leftStartUp',
                'rightStartUp',
                'leftStartDown',
                'rightStartDown',
                'upStartLeft',
                'upStartRight',
                'downCenter',
                'upCenter',
              ]}
              onMouseEnter={popoverOnMouseEnter}
              onMouseLeave={popoverOnMouseLeave}
            >
              <Informer
                title={titleMap[status]}
                label={statusMessage}
                view="bordered"
                status={status}
              />
            </Popover>
          )}
        </Transition>
      )}
    </>
  );
};

const columns: TableColumn<Row>[] = [
  {
    title: 'Имя',
    accessor: 'name',
    renderCell: ({ row, tableRef }) => (
      <DataCellWithInformer
        data={row.name.data}
        status={row.name.status}
        statusMessage={row.name.statusMessage}
        tableRef={tableRef}
      />
    ),
  },
  {
    title: 'Профессия',
    accessor: 'profession',
    renderCell: ({ row, tableRef }) => (
      <DataCellWithInformer
        data={row.profession.data}
        status={row.profession.status}
        statusMessage={row.profession.statusMessage}
        tableRef={tableRef}
      />
    ),
  },
  {
    title: 'Статус',
    accessor: 'status',
    renderCell: ({ row, tableRef }) => (
      <DataCellWithInformer
        data={row.status.data}
        status={row.status.status}
        statusMessage={row.status.statusMessage}
        tableRef={tableRef}
      />
    ),
  },
];

export const TableExampleWithIndicator = () => {
  return (
      <Table
        style={{ maxHeight: 400 }}
        rows={rows}
        columns={columns}
        headerZIndex={5}
        stickyHeader
      />
  );
};
```

</MdxTabs>

## Ключ строки

Чтобы оптимизировать рендеринг, укажите уникальный ключ строки в `getRowKey`.

<MdxInformer status="normal">

Если не указывать ключ строки, компонент попытается взять `row.id`. В случае, если и там ничего нет — `index`. При этом ключи ячеек будут брать ключ строки и добавлять к нему `accessor`.

</MdxInformer>

```tsx
<Table columns={columns} rows={rows} getRowKey={(row) => row.uniqueKey} />
```

## Адаптивная ширина колонок

Вы можете менять ширину колонок в зависимости от ширины самой таблицы.

<MdxTabs>

<TableExampleAdaptiveColumns />

```tsx
import { Example } from '@consta/stand';
import { Button } from '@consta/uikit/Button';
import { getLastPoint, useBreakpoints } from '@consta/uikit/useBreakpoints';
import React, { useCallback, useMemo, useRef, useState } from 'react';

import { Table, TableColumn } from '@consta/table/Table';

type Row = { name: string; profession: string; status: string };

const rows: Row[] = [
  {
    name: 'Антон',
    profession: 'Строитель, который построил дом',
    status: 'недоступен',
  },
  {
    name: 'Василий',
    profession: 'Отвечает на вопросы, хотя его не спросили',
    status: 'на связи',
  },
];

const columnsWidthMap: Record<
  's' | 'm' | 'l',
  Record<'name' | 'profession' | 'status', TableColumn<Row>>
> = {
  s: {
    name: {
      width: 100,
      minWidth: 100,
      maxWidth: 100,
    },
    profession: {
      width: '1fr',
      minWidth: 150,
    },
    status: {
      width: 120,
      minWidth: 120,
      maxWidth: 120,
    },
  },
  m: {
    name: {
      width: 120,
      minWidth: 120,
      maxWidth: 120,
    },
    profession: {
      width: '1fr',
      minWidth: 250,
    },
    status: {
      width: 120,
      minWidth: 120,
      maxWidth: 120,
    },
  },
  l: {
    name: {
      width: 150,
      minWidth: 150,
      maxWidth: 150,
    },
    profession: {
      width: '1fr',
    },
    status: {
      width: 150,
      minWidth: 150,
      maxWidth: 150,
    },
  },
};

const breakpointsMap = { s: 300, m: 500, l: 760 };
const breakpointsSequence: (keyof typeof breakpointsMap)[] = ['s', 'm', 'l'];

export const TableExampleAdaptiveColumns = () => {
  const [widthSequence, setWidthSequence] = useState(0);

  const handleWidthChange = useCallback(() => {
    setWidthSequence((state) => {
      const newState = state + 1;
      return newState >= breakpointsSequence.length ? 0 : newState;
    });
  }, []);

  const tableRef = useRef<HTMLDivElement>(null);

  const point =
    getLastPoint(
      useBreakpoints({
        ref: tableRef,
        map: breakpointsMap,
        isActive: true,
      }),
    ) || 's';

  const columns: TableColumn<Row>[] = useMemo(
    () => [
      {
        title: 'Имя',
        accessor: 'name',
        ...columnsWidthMap[point].name,
      },
      {
        title: 'Профессия',
        accessor: 'profession',
        ...columnsWidthMap[point].profession,
      },
      {
        title: 'Статус',
        accessor: 'status',
        ...columnsWidthMap[point].status,
      },
    ],
    [point],
  );

  return (
    <>
      <Table
        ref={tableRef}
        style={{
          outline: '1px solid red',
          width: breakpointsMap[breakpointsSequence[widthSequence]],
        }}
        rows={rows}
        columns={columns}
      />
      <Button onClick={handleWidthChange} label="Изменить ширину" />
    </>
  );
};
```

</MdxTabs>

## Свойства

```ts
export type TableRenderHeaderCell = (props: {
  title?: string;
  index: number;
}) => React.ReactNode | null;

export type TableRenderCell<T> = (props: {
  row: T;
  rowIndex: number;
  columnIndex: number;
}) => React.ReactNode | null;

export type TableColumn<ROW> = {
  title?: string;
  width?:
    | number
    | 'auto'
    | '1fr'
    | '2fr'
    | '3fr'
    | '4fr'
    | '5fr'
    | '6fr'
    | '7fr'
    | '8fr'
    | '9fr'
    | '10fr';
  maxWidth?: number;
  minWidth?: number;
  renderHeaderCell?: TableRenderHeaderCell;
  isSeparator?: boolean;
  pinned?: TableColumnPropPinned;
  renderCell?: TableRenderCell<ROW>;
  colSpan?: TabletColSpan<ROW>;
  accessor?: string;
  columns?: TableColumn<ROW>[];
};

type TableRowMouseEvent<ROW> = (
  row: ROW,
  props: { e: React.MouseEvent },
) => void;

type GetRowKey<ROW> = (row: ROW) => string | number;
```

| Свойство           | Тип                           | По умолчанию      | Описание                                                     |
| ------------------ | ----------------------------- | ----------------- | ------------------------------------------------------------ |
| `columns?`         | `TableColumn[]`               | -                 | Колонки                                                      |
| `rows?`            | `ROW[]`                       | -                 | Строки                                                       |
| `getRowKey?`       | `GetRowKey<ROW>`              | `(row) => row.id` | Функция получения ключа, если ключ не найден берется `index` |
| `onRowMouseEnter?` | `TableRowMouseEvent<ROW>`     | -                 | Событие `onMouseEnter` на строке                             |
| `onRowMouseLeave?` | `TableRowMouseEvent<ROW>`     | -                 | Событие `onMouseLeave` на строке                             |
| `onRowClick?`      | `TableRowMouseEvent<ROW>`     | -                 | Событие `onClick` на строке                                  |
| `virtualScroll?`   | `boolean`                     | -                 | Включение виртуальной прокрутки                              |
| `stickyHeader?`    | `boolean`                     | -                 | Зафиксировать шапку сверху                                   |
| `resizable?`       | `'inside'` &#124; `'outside'` | -                 | Включение возможности изменять ширину колонок                |
| `zebraStriped?`    | `boolean`                     | -                 | Окрашивание строк через одну                                 |
| `headerZIndex?`    | `number`                      | `1`               | `zIndex` шапки                                               |
| `rowHoverEffect?`  | `boolean`                     | -                 | Включает эффект наведения на строку                          |
| `className?`       | `string`                      | -                 | Дополнительный CSS-класс                                     |
| `ref?`             | `React.Ref<HTMLDivElement>`   | -                 | Ссылка на корневой DOM-элемент                               |
